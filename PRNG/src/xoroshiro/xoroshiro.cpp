#include "xoroshiro.hpp"
#include "config.hpp"


xoroshiro128plus_gen::result_type

/**
 * It calculates the xoroshiro128+ result
 *
 * @return result: uint64_t which is the random value generated by the algorithm
 */
xoroshiro128plus_gen::operator()() {
    // Copying state to operate with it
    const uint64_t s0 = state[0];
    uint64_t s1 = state[1];

    // Sum of the previous states -> Scrambler +
    const uint64_t result = s0 + s1;

    // S1 = State1 XOR State0
    s1 ^= s0;

    // Update the states - Refer to Figure 1.3 of the report for the graphic representation
    state[0] = rotl(s0, GEN_A) ^ s1 ^ (s1 << GEN_B);
    state[1] = rotl(s1, GEN_C);

    return result;
}

/**
 * Using an input function "f", it creates the initial values for state[]
 *
 * @param f: input function to generate the auxiliary values
 */
void xoroshiro128plus_gen::seed(std::function<uint32_t(void)> f) {
    // Uses the function passed as an argument to calculated x_0 and x_1
    uint64_t x_0 = f();
    uint64_t x_1 = f();
    // Calculates the initial state[0] using x_0 and x_1
    state[0] = (x_0 << 32) | x_1;

    x_0 = f();
    x_1 = f();
    // Calculates the initial state[1] using x_0 and x_1
    state[1] = (x_0 << 32) | x_1;
}

void xoroshiro128plus_gen::seed(const std::array<uint32_t, 4> &a) {
    state[0] = ((uint64_t) a[0] << 32) | (uint64_t) a[1];
    state[1] = ((uint64_t) a[2] << 32) | (uint64_t) a[3];
}

